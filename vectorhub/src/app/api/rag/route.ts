import { NextResponse } from "next/server";
import { mockDbClient } from "@/lib/db/client";
import { logger } from "@/lib/logger";
import type { SearchResult } from "@/lib/db/adapters/base";

interface RAGRequest {
    query: string;
    collection?: string;
    topK?: number;
    minScore?: number;
    agent?: {
        type: "mcp" | "webhook" | "mock";
        endpoint?: string;
        name?: string;
        config?: {
            type?: "stdio" | "sse";
            command?: string;
            args?: string[];
            url?: string;
            baseUrl?: string;
        };
    };
}

interface RAGResponse {
    response: string;
    context: SearchResult[];
    agentUsed: string;
}

// Generate a helpful response based on query and context
function generateResponse(query: string, context: SearchResult[], agentName?: string): string {
    if (context.length === 0) {
        return `I searched the vector database for information about "${query}" but didn't find any matching documents.

**Suggestions:**
- Try uploading documents related to your query
- Rephrase your question with different keywords
- Lower the minimum similarity score in the settings

${agentName ? `\n*Response generated by: ${agentName}*` : ""}`;
    }

    const contextSummary = context
        .slice(0, 3)
        .map((c, i) => {
            const source = (c.metadata?.source as string) || `Document ${i + 1}`;
            const preview = c.content?.slice(0, 300) || "No content available";
            return `**[${i + 1}] ${source}** (${(c.score * 100).toFixed(0)}% match)\n${preview}${c.content && c.content.length > 300 ? "..." : ""}`;
        })
        .join("\n\n");

    return `Based on ${context.length} relevant document(s) found in your vector database:

${contextSummary}

---
*Retrieved ${context.length} documents with similarity scores from ${(context[context.length - 1]?.score * 100).toFixed(0)}% to ${(context[0]?.score * 100).toFixed(0)}%*
${agentName ? `*Response via: ${agentName}*` : ""}`;
}

// Call any AI agent via HTTP (works for MCP SSE, webhooks, n8n, etc.)
async function callHttpAgent(
    url: string,
    query: string,
    context: SearchResult[],
    agentName: string
): Promise<string> {
    logger.info(`Calling HTTP agent: ${agentName} at ${url}`);
    
    const response = await fetch(url, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "Accept": "application/json",
        },
        body: JSON.stringify({
            // Send in multiple formats for compatibility with different platforms
            query,
            message: query,
            prompt: query,
            text: query,
            context: context.map((c) => ({
                content: c.content,
                score: c.score,
                relevance: c.score,
                metadata: c.metadata,
                source: c.metadata?.source,
            })),
            documents: context.map((c) => c.content),
            timestamp: new Date().toISOString(),
        }),
    });

    if (!response.ok) {
        const errorText = await response.text().catch(() => "Unknown error");
        throw new Error(`Agent returned ${response.status}: ${errorText}`);
    }

    const data = await response.json();
    
    // Handle various response formats from different platforms
    const result = 
        data.response || 
        data.message || 
        data.content || 
        data.text || 
        data.output || 
        data.result?.content ||
        data.result ||
        data.completion ||
        data.answer;
    
    if (typeof result === "string") {
        return result;
    } else if (result) {
        return typeof result === "object" ? JSON.stringify(result, null, 2) : String(result);
    }
    
    // If no known field, return the whole response
    return JSON.stringify(data, null, 2);
}

export async function POST(request: Request) {
    try {
        const body: RAGRequest = await request.json();
        const { query, collection, topK = 5, minScore = 0.5, agent } = body;

        if (!query) {
            return NextResponse.json(
                {
                    code: "VALIDATION_ERROR",
                    message: "Query is required",
                },
                { status: 400 }
            );
        }

        // Step 1: Retrieve relevant context from vector database (if collection specified)
        let context: SearchResult[] = [];
        
        if (collection) {
            try {
                context = await mockDbClient.search(collection, {
                    text: query,
                    topK,
                    minScore,
                    includeContent: true,
                    includeMetadata: true,
                });
                logger.info(`Retrieved ${context.length} documents from collection "${collection}"`);
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : "Unknown error";
                logger.warn(`Collection search failed: ${errorMessage}`);
                // Continue without context rather than failing
            }
        }

        // Step 2: Generate response based on agent type
        let response: string;
        let agentUsed: string;
        const agentName = agent?.name || "Vector Search";

        if (!agent || agent.type === "mock") {
            // Use built-in response generator
            response = generateResponse(query, context, "Vector Search");
            agentUsed = "Vector Search";
        } else {
            // For both webhook and MCP types, try to call the HTTP endpoint
            const endpoint = agent.endpoint || agent.config?.url || agent.config?.baseUrl;
            
            if (endpoint) {
                try {
                    response = await callHttpAgent(endpoint, query, context, agentName);
                    agentUsed = agentName;
                } catch (err) {
                    const errorMsg = err instanceof Error ? err.message : "Unknown error";
                    logger.error(`Agent call failed (${agent.type}): ${errorMsg}`);
                    response = generateResponse(query, context, agentName);
                    response += `\n\n‚ö†Ô∏è *Could not reach ${agentName}.*\n*Error: ${errorMsg}*`;
                    agentUsed = `${agentName} (fallback)`;
                }
            } else {
                // No endpoint - use vector search only
                response = generateResponse(query, context, "Vector Search");
                response += `\n\nüí° *No HTTP endpoint configured for ${agentName}. Please add a webhook URL in the connection settings.*`;
                agentUsed = "Vector Search";
            }
        }

        const result: RAGResponse = {
            response,
            context,
            agentUsed,
        };

        return NextResponse.json(result);
    } catch (error) {
        logger.error("POST /api/rag failed", error instanceof Error ? error : undefined);
        return NextResponse.json(
            {
                code: "INTERNAL_ERROR",
                message: error instanceof Error ? error.message : "Failed to process RAG request",
            },
            { status: 500 }
        );
    }
}

